from __future__ import division

import numpy as np

import testutil

import pysynphot as S

# test whether the InterpolatedSpectralElement grabs the correct column
# when the input value is a column (no interpolation required) and an "ERROR"
# column is present
class InterpErrorColCase(testutil.FPTestCase):
  def setUp(self):
    interp_val = 51252.0
    filename = '/grp/hst/cdbs/comp/stis/stis_nm16_mjd_010_syn.fits[MJD#]'
    self.spec = S.spectrum.InterpolatedSpectralElement(filename,interp_val)
    
  def test_throughput(self):
    throughput = \
      np.array([ 0.      ,  0.965065,  0.965065,  0.965065,  0.963328,  0.976245,
                  0.983497,  0.984206,  0.976436,  0.963131,  0.950973,  0.952877,
                  0.951205,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,  0.980966,
                  0.980966,  0.980966,  0.980966,  0.      ])
    
    self.assertEqualNumpy(self.spec._throughputtable,throughput)
    
  def test_wavetable(self):
    wavetable = \
      np.array([  1049.,   1050.,   1100.,   1150.,   1200.,   1250.,   1300.,
         1350.,   1400.,   1450.,   1500.,   1550.,   1600.,   1650.,
         1700.,   1750.,   1800.,   1850.,   1900.,   1950.,   2000.,
         2050.,   2100.,   2150.,   2200.,   2250.,   2300.,   2350.,
         2400.,   2450.,   2500.,   2550.,   2600.,   2650.,   2700.,
         2750.,   2800.,   2850.,   2900.,   2950.,   3000.,   3050.,
         3100.,   3150.,   3200.,   3250.,   3300.,   3350.,   3400.,
         3450.,   3500.,   3550.,   3600.,   3650.,   3700.,   3750.,
         3800.,   3850.,   3900.,   3950.,   4000.,   4050.,   4100.,
         4150.,   4200.,   4250.,   4300.,   4350.,   4400.,   4450.,
         4500.,   4550.,   4600.,   4650.,   4700.,   4750.,   4800.,
         4850.,   4900.,   4950.,   5000.,   5050.,   5100.,   5150.,
         5200.,   5250.,   5300.,   5350.,   5400.,   5450.,   5500.,
         5550.,   5600.,   5650.,   5700.,   5750.,   5800.,   5850.,
         5900.,   5950.,   6000.,   6050.,   6100.,   6150.,   6200.,
         6250.,   6300.,   6350.,   6400.,   6450.,   6500.,   6550.,
         6600.,   6650.,   6700.,   6750.,   6800.,   6850.,   6900.,
         6950.,   7000.,   7050.,   7100.,   7150.,   7200.,   7250.,
         7300.,   7350.,   7400.,   7450.,   7500.,   7550.,   7600.,
         7650.,   7700.,   7750.,   7800.,   7850.,   7900.,   7950.,
         8000.,   8050.,   8100.,   8150.,   8200.,   8250.,   8300.,
         8350.,   8400.,   8450.,   8500.,   8550.,   8600.,   8650.,
         8700.,   8750.,   8800.,   8850.,   8900.,   8950.,   9000.,
         9050.,   9100.,   9150.,   9200.,   9250.,   9300.,   9350.,
         9400.,   9450.,   9500.,   9550.,   9600.,   9650.,   9700.,
         9750.,   9800.,   9850.,   9900.,   9950.,  10000.,  10050.,
        10100.,  10150.,  10200.,  10250.,  10300.,  10350.,  10400.,
        10450.,  10500.,  10550.,  10600.,  10650.,  10700.,  10750.,
        10800.,  10850.,  10900.,  10950.,  11000.,  11001.])
        
    self.assertEqualNumpy(self.spec._wavetable,wavetable)

# test whether the InterpolatedSpectralElement grabs the correct column
# when the input value is the first column (no interpolation required) and 
# there is no "throughput" (default) column present, meaning that the 
# interpolation columns start at column 1
class InterpNoDefaultCase(testutil.FPTestCase):
  def setUp(self):
    interp_val = 0.0
    filename = '/grp/hst/cdbs/comp/acs/acs_wfc_aper_002_syn.fits[aper#]'
    self.spec = S.spectrum.InterpolatedSpectralElement(filename,interp_val)
    
  def test_throughput(self):
    throughput = \
      np.array([ 0.28      ,  0.22      ,  0.20999999,  0.22      ,  0.22      ,
        0.2       ,  0.15000001,  0.1       ,  0.04      ], dtype=np.float32)
    
    self.assertEqualNumpy(self.spec._throughputtable,throughput)
    
  def test_wavetable(self):
    wavetable = \
      np.array([  3500.,   4000.,   5000.,   6000.,   7000.,   8000.,   9000.,
        10000.,  11000.], dtype=np.float32)
        
    self.assertEqualNumpy(self.spec._wavetable,wavetable)
    
# test whether the InterpolatedSpectralElement gets the correct throughput table
# in the event that it is passed a value that does not correspond to a column
# and interpolation is required.
class InterpInterpolationRequiredCase(testutil.FPTestCase):
  def setUp(self):
    interp_val = 51000.0
    filename = '/grp/hst/cdbs/comp/stis/stis_nm16_mjd_010_syn.fits[MJD#]'
    self.spec = S.spectrum.InterpolatedSpectralElement(filename,interp_val)
    
  def test_throughput(self):
    throughput = \
      np.array([ 0.        ,  0.98676147,  0.98676147,  0.98676147,  0.98610324,
        0.99099811,  0.99374623,  0.99401491,  0.99107048,  0.98602859,
        0.98142135,  0.98214286,  0.98150926,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.99278712,  0.99278712,  0.99278712,  0.99278712,
        0.99278712,  0.        ])
    
    self.assertEqual(self.spec._throughputtable[0],throughput[0])
    self.assertEqual(self.spec._throughputtable[-1],throughput[-1])
    self.assertApproxNumpy(self.spec._throughputtable[1:-1],throughput[1:-1])
    
  def test_wavetable(self):
    wavetable = \
      np.array([  1049.,   1050.,   1100.,   1150.,   1200.,   1250.,   1300.,
         1350.,   1400.,   1450.,   1500.,   1550.,   1600.,   1650.,
         1700.,   1750.,   1800.,   1850.,   1900.,   1950.,   2000.,
         2050.,   2100.,   2150.,   2200.,   2250.,   2300.,   2350.,
         2400.,   2450.,   2500.,   2550.,   2600.,   2650.,   2700.,
         2750.,   2800.,   2850.,   2900.,   2950.,   3000.,   3050.,
         3100.,   3150.,   3200.,   3250.,   3300.,   3350.,   3400.,
         3450.,   3500.,   3550.,   3600.,   3650.,   3700.,   3750.,
         3800.,   3850.,   3900.,   3950.,   4000.,   4050.,   4100.,
         4150.,   4200.,   4250.,   4300.,   4350.,   4400.,   4450.,
         4500.,   4550.,   4600.,   4650.,   4700.,   4750.,   4800.,
         4850.,   4900.,   4950.,   5000.,   5050.,   5100.,   5150.,
         5200.,   5250.,   5300.,   5350.,   5400.,   5450.,   5500.,
         5550.,   5600.,   5650.,   5700.,   5750.,   5800.,   5850.,
         5900.,   5950.,   6000.,   6050.,   6100.,   6150.,   6200.,
         6250.,   6300.,   6350.,   6400.,   6450.,   6500.,   6550.,
         6600.,   6650.,   6700.,   6750.,   6800.,   6850.,   6900.,
         6950.,   7000.,   7050.,   7100.,   7150.,   7200.,   7250.,
         7300.,   7350.,   7400.,   7450.,   7500.,   7550.,   7600.,
         7650.,   7700.,   7750.,   7800.,   7850.,   7900.,   7950.,
         8000.,   8050.,   8100.,   8150.,   8200.,   8250.,   8300.,
         8350.,   8400.,   8450.,   8500.,   8550.,   8600.,   8650.,
         8700.,   8750.,   8800.,   8850.,   8900.,   8950.,   9000.,
         9050.,   9100.,   9150.,   9200.,   9250.,   9300.,   9350.,
         9400.,   9450.,   9500.,   9550.,   9600.,   9650.,   9700.,
         9750.,   9800.,   9850.,   9900.,   9950.,  10000.,  10050.,
        10100.,  10150.,  10200.,  10250.,  10300.,  10350.,  10400.,
        10450.,  10500.,  10550.,  10600.,  10650.,  10700.,  10750.,
        10800.,  10850.,  10900.,  10950.,  11000.,  11001.])
        
    self.assertEqualNumpy(self.spec._wavetable,wavetable)
    
